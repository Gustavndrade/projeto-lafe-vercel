---
description: Regras completas de desenvolvimento (Sistema Jogos UNIFUNEC)
alwaysApply: true
---

# ğŸ¯ REGRAS DE DESENVOLVIMENTO - SISTEMA JOGOS UNIFUNEC

## ğŸ“‹ PRINCÃPIOS FUNDAMENTAIS

### 1. ARQUITETURA EM CAMADAS (OBRIGATÃ“RIO)

- Controller â†’ Service â†’ Repository â†’ Model
- SeparaÃ§Ã£o de responsabilidades clara
- InjeÃ§Ã£o de dependÃªncias via construtor
- Nunca pular camadas (ex.: Controller chamando Repository diretamente)

### 2. VALIDAÃ‡ÃƒO MANUAL SIMPLES (OBRIGATÃ“RIO)

- SEMPRE usar validaÃ§Ã£o manual (sem Joi, Yup, etc.)
- SEMPRE validar nas rotas com middleware
- NUNCA duplicar validaÃ§Ãµes entre Controller e Service
- SEMPRE retornar array de strings com erros em portuguÃªs

### 3. TRATAMENTO DE ERROS (OBRIGATÃ“RIO)

- SEMPRE usar AppError para erros customizados
- SEMPRE usar next(error) no Controller
- SEMPRE retornar mensagens em portuguÃªs
- NUNCA usar console.log para erros

### 4. ESTRUTURA DE PASTAS (OBRIGATÃ“RIO)

src/modules/[resource]/
â”œâ”€â”€ controllers/
â”œâ”€â”€ services/
â”œâ”€â”€ repositories/
â”œâ”€â”€ models/
â”œâ”€â”€ dtos/
â”œâ”€â”€ routes.ts
â””â”€â”€ README.md

### 5. DTOs E INTERFACES (OBRIGATÃ“RIO)

- SEMPRE criar DTOs separados (Request, Response, Update)
- SEMPRE usar interfaces TypeScript bem definidas
- SEMPRE incluir timestamps (createdAt, updatedAt)
- NUNCA expor senhas em DTOs de resposta

## ğŸ”§ PADRÃ•ES DE CÃ“DIGO

### Controller (HTTP Layer) â€” CORRETO

```ts
async createUser(req: Request, res: Response, next: NextFunction): Promise<any> {
  try {
    const user = await this.userService.createUser(req.body);
    return res.status(201).json(user);
  } catch (error) {
    next(error);
  }
}
```

### Controller â€” ERRADO

```ts
async createUser(req: Request, res: Response): Promise<any> {
  const user = await this.userService.createUser(req.body);
  return res.status(201).json(user);
}
```

### Service (Regra de NegÃ³cio) â€” CORRETO

```ts
async createUser(user: UserRequestDTO): Promise<UserResponseDTO> {
  user.password = await hashPassword(user.password);
  const userResponse = await this.userRepository.createUser(user);
  return userResponse.toResponse();
}
```

### Service â€” ERRADO (validaÃ§Ã£o aqui Ã© proibida)

```ts
async createUser(user: UserRequestDTO): Promise<UserResponseDTO> {
  if (!user.name) throw new Error("Nome obrigatÃ³rio");
  return await this.userRepository.createUser(user);
}
```

### Repository (Acesso a Dados) â€” CORRETO

```ts
async createUser(user: UserRequestDTO): Promise<UserModel> {
  const emailFound = await prisma.user.findUnique({ where: { email: user.email } });
  if (emailFound) throw new AppError("E-mail jÃ¡ cadastrado", 400);

  const createdUser = await prisma.user.create({ data: user.dataToPrisma() });
  return UserModel.prismaToModel(createdUser);
}
```

### Repository â€” ERRADO

```ts
async createUser(user: UserRequestDTO): Promise<UserModel> {
  return await prisma.user.create({ data: user });
}
```

## ğŸ›¡ï¸ VALIDAÃ‡Ã•ES OBRIGATÃ“RIAS

### 1) ValidaÃ§Ã£o de Email

```ts
export function validateEmailFormat(email: string): string[] {
  const errors: string[] = [];
  if (!email) {
    errors.push("E-mail Ã© obrigatÃ³rio");
    return errors;
  }
  // regex robusta para formato de e-mail
  return errors;
}
```

### 2) ValidaÃ§Ã£o de ID

```ts
export function validateUserId(params: any): string[] {
  const errors: string[] = [];
  if (!params.id) errors.push("ID Ã© obrigatÃ³rio");
  else if (isNaN(Number(params.id))) errors.push("ID deve ser um nÃºmero");
  else if (Number(params.id) <= 0)
    errors.push("ID deve ser um nÃºmero positivo");
  return errors;
}
```

### 3) ValidaÃ§Ã£o de PaginaÃ§Ã£o

```ts
export function validatePaginationQuery(query: any): string[] {
  const errors: string[] = [];
  if (query.page !== undefined) {
    const pageNum = Number(query.page);
    if (isNaN(pageNum) || !Number.isInteger(pageNum) || pageNum < 1) {
      errors.push("Page deve ser um nÃºmero inteiro positivo");
    }
  }
  return errors;
}
```

## ğŸ” SEGURANÃ‡A

### Hash de Senhas (SEMPRE)

```ts
import { hashPassword } from '../../shared/utils/Hash';
async createUser(user: UserRequestDTO): Promise<UserResponseDTO> {
  user.password = await hashPassword(user.password);
  // ...
}
```

### Timestamps AutomÃ¡ticos (Prisma)

```prisma
model User {
  id        Int      @id @default(autoincrement())
  // outros campos...
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
```

### ValidaÃ§Ã£o de Dados (exemplo CreateUser)

```ts
export function validateCreateUser(data: any): string[] {
  const errors: string[] = [];
  if (!data.name || data.name.length < 2) {
    errors.push("Nome deve ter pelo menos 2 caracteres");
  }
  return errors;
}
```

## ğŸ“Š PAGINAÃ‡ÃƒO OBRIGATÃ“RIA

### Interface

```ts
interface PaginationResponse<T> {
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}
```

### ImplementaÃ§Ã£o no Repository

```ts
async listUsersPaginated(query: PaginationQuery): Promise<PaginationResponse<UserModel>> {
  const page = query.page || 1;
  const limit = query.limit || 10;
  const skip = (page - 1) * limit;

  const [users, total] = await Promise.all([
    prisma.user.findMany({ where, skip, take: limit, orderBy: { createdAt: 'desc' } }),
    prisma.user.count({ where })
  ]);

  const totalPages = Math.ceil(total / limit);
  return {
    data: users.map(user => UserModel.prismaToModel(user)),
    pagination: { page, limit, total, totalPages, hasNext: page < totalPages, hasPrev: page > 1 }
  };
}
```

## ğŸ“ DOCUMENTAÃ‡ÃƒO OBRIGATÃ“RIA

### README.md em cada mÃ³dulo

- SEMPRE criar README detalhado com exemplos de requisiÃ§Ãµes, cÃ³digos de resposta, validaÃ§Ãµes e regras.

### Collection Postman

- SEMPRE criar collection completa com exemplos de resposta, variÃ¡veis de ambiente e scripts de teste.

### Pasta de Testes

src/modules/[resource]/teste/
â”œâ”€â”€ Collection_Postman.json
â”œâ”€â”€ Exemplos_Completos.md
â”œâ”€â”€ Cenarios_Teste.md
â””â”€â”€ README.md

## ğŸš« O QUE NUNCA FAZER

- Usar bibliotecas de validaÃ§Ã£o externas (Joi, Yup, etc.)
- Duplicar validaÃ§Ãµes entre camadas
- Usar console.log para erros
- Pular camadas da arquitetura
- Expor senhas em DTOs de resposta
- Usar IDs fixos em testes
- Criar mÃ³dulos sem documentaÃ§Ã£o
- Usar any sem necessidade
- NÃ£o tratar erros adequadamente
- Criar rotas sem validaÃ§Ã£o

### âŒ Estrutura proibida (exemplo)

```ts
async createUser(req: Request, res: Response): Promise<any> {
  if (!req.body.name) return res.status(400).json({ error: "Nome obrigatÃ³rio" });
  const user = await this.userRepository.createUser(req.body);
  return res.status(201).json(user);
}
```

## âœ… CHECKLIST OBRIGATÃ“RIO

### Por mÃ³dulo

- [ ] Estrutura de pastas correta
- [ ] Controller, Service, Repository, Model implementados
- [ ] DTOs separados (Request, Response, Update)
- [ ] ValidaÃ§Ãµes nas rotas com middleware
- [ ] Tratamento de erros com AppError
- [ ] Hash de senhas implementado
- [ ] Timestamps no schema Prisma
- [ ] PaginaÃ§Ã£o implementada
- [ ] README.md completo
- [ ] Collection Postman criada
- [ ] Pasta de testes com exemplos

### Por endpoint

- [ ] ValidaÃ§Ã£o de entrada
- [ ] Tratamento de erros
- [ ] Resposta padronizada
- [ ] CÃ³digos de status corretos
- [ ] DocumentaÃ§Ã£o atualizada

## ğŸ¯ OBJETIVOS DE QUALIDADE

### CÃ³digo

- Consistente, legÃ­vel, testÃ¡vel, seguro e escalÃ¡vel (camadas)

### DocumentaÃ§Ã£o

- Completa, atualizada, testÃ¡vel (Postman) e acessÃ­vel

## ğŸš€ APLICAÃ‡ÃƒO DAS REGRAS

### SEMPRE seguir:

1. Arquitetura em camadas
2. ValidaÃ§Ã£o manual
3. Tratamento de erros
4. DocumentaÃ§Ã£o completa
5. Testes organizados

### NUNCA quebrar:

1. NÃ£o usar libs de validaÃ§Ã£o externas
2. NÃ£o duplicar validaÃ§Ãµes
3. NÃ£o pular camadas
4. NÃ£o criar mÃ³dulos sem documentaÃ§Ã£o
5. NÃ£o usar console.log para erros
